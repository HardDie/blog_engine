// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.26.0
// source: user.sql

package user

import (
	"context"
	"database/sql"
	"time"
)

const create = `-- name: Create :one
INSERT INTO users (username, displayed_name, invited_by_user)
VALUES (?, ?, ?)
RETURNING id, username, displayed_name, email, invited_by_user, created_at, updated_at, deleted_at
`

type CreateParams struct {
	Username      string `json:"username"`
	DisplayedName string `json:"displayedName"`
	InvitedByUser int64  `json:"invitedByUser"`
}

func (q *Queries) Create(ctx context.Context, arg CreateParams) (*User, error) {
	row := q.queryRow(ctx, q.createStmt, create, arg.Username, arg.DisplayedName, arg.InvitedByUser)
	var i User
	err := row.Scan(
		&i.ID,
		&i.Username,
		&i.DisplayedName,
		&i.Email,
		&i.InvitedByUser,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return &i, err
}

const getByIDPrivate = `-- name: GetByIDPrivate :one
SELECT id, username, displayed_name, email, invited_by_user, created_at, updated_at, deleted_at
FROM users
WHERE id = ?
  AND deleted_at IS NULL
`

func (q *Queries) GetByIDPrivate(ctx context.Context, id int64) (*User, error) {
	row := q.queryRow(ctx, q.getByIDPrivateStmt, getByIDPrivate, id)
	var i User
	err := row.Scan(
		&i.ID,
		&i.Username,
		&i.DisplayedName,
		&i.Email,
		&i.InvitedByUser,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return &i, err
}

const getByIDPublic = `-- name: GetByIDPublic :one
SELECT id, displayed_name, invited_by_user, created_at, updated_at, deleted_at
FROM users
WHERE id = ?
  AND deleted_at IS NULL
`

type GetByIDPublicRow struct {
	ID            int64        `json:"id"`
	DisplayedName string       `json:"displayedName"`
	InvitedByUser int64        `json:"invitedByUser"`
	CreatedAt     time.Time    `json:"createdAt"`
	UpdatedAt     time.Time    `json:"updatedAt"`
	DeletedAt     sql.NullTime `json:"deletedAt"`
}

func (q *Queries) GetByIDPublic(ctx context.Context, id int64) (*GetByIDPublicRow, error) {
	row := q.queryRow(ctx, q.getByIDPublicStmt, getByIDPublic, id)
	var i GetByIDPublicRow
	err := row.Scan(
		&i.ID,
		&i.DisplayedName,
		&i.InvitedByUser,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return &i, err
}

const getByName = `-- name: GetByName :one
SELECT id, username, displayed_name, email, invited_by_user, created_at, updated_at, deleted_at
FROM users
WHERE username = ?
  AND deleted_at IS NULL
`

func (q *Queries) GetByName(ctx context.Context, username string) (*User, error) {
	row := q.queryRow(ctx, q.getByNameStmt, getByName, username)
	var i User
	err := row.Scan(
		&i.ID,
		&i.Username,
		&i.DisplayedName,
		&i.Email,
		&i.InvitedByUser,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return &i, err
}

const update = `-- name: Update :one
UPDATE users
SET displayed_name = ?, email = ?, updated_at = datetime('now')
WHERE id = ?
  AND deleted_at IS NULL
RETURNING id, username, displayed_name, email, invited_by_user, created_at, updated_at, deleted_at
`

type UpdateParams struct {
	DisplayedName string         `json:"displayedName"`
	Email         sql.NullString `json:"email"`
	ID            int64          `json:"id"`
}

func (q *Queries) Update(ctx context.Context, arg UpdateParams) (*User, error) {
	row := q.queryRow(ctx, q.updateStmt, update, arg.DisplayedName, arg.Email, arg.ID)
	var i User
	err := row.Scan(
		&i.ID,
		&i.Username,
		&i.DisplayedName,
		&i.Email,
		&i.InvitedByUser,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return &i, err
}
